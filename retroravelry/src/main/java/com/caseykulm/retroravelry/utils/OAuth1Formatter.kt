package com.caseykulm.retroravelry.utils

import com.google.common.net.UrlEscapers
import okhttp3.HttpUrl
import okhttp3.Request
import okio.Buffer
import java.util.*
import okio.ByteString
import kotlin.collections.HashMap


class OAuth1Formatter(
        val consumerKey: String,
        val consumerSecret: String,
        val calendar: Calendar,
        val random: Random) {
    val escaper = UrlEscapers.urlFormParameterEscaper()

    /**
     * The timestamp value MUST be a positive integer.  Unless otherwise
     * specified by the server's documentation, the timestamp is expressed
     * in the number of seconds since January 1, 1970 00:00:00 GMT.
     *
     * https://tools.ietf.org/html/rfc5849#section-3.3
     */
    fun generateTimestamp(): String {
        val timeInSeconds = calendar.timeInMillis / 1000
        return timeInSeconds.toString()
    }

    /**
     * A nonce is a random string, uniquely generated by the client to allow
     * the server to verify that a request has never been made before and
     * helps prevent replay attacks when requests are made over a non-secure
     * channel. The nonce value MUST be unique across all requests with the
     * same timestamp, client credentials, and token combinations.
     *
     * https://tools.ietf.org/html/rfc5849#section-3.3
     */
    fun generateNonce(): String {
        val nonceBytes = ByteArray(32)
        random.nextBytes(nonceBytes)
        val nonce = ByteString.of(*nonceBytes).base64().replace("\\W".toRegex(), "")
        return nonce
    }

    /**
     *
     * https://tools.ietf.org/html/rfc5849#section-3.4
     */
    fun generateSignature(): String {
        TODO("Need to implement signature per RFC")
    }

    /**
     * https://tools.ietf.org/html/rfc5849#section-3.4.1
     */
    fun generateSignatureBaseString(
            request: Request,
            oAuthMetaData: OAuthMetaData) : String {
        val requestMethodEncoded = escaper.escape(request.method())
        var requestUrlPart = ""
        if (request.url().isHttps) {
            requestUrlPart += "https://"
        } else {
            requestUrlPart += "http://"
        }
        requestUrlPart += request.url().host()
        requestUrlPart += request.url().encodedPath()
        val requestUrlEncoded = escaper.escape(requestUrlPart)

        val queryParamMap = HashMap<String, String>()
        for (i in 0..request.url().querySize() - 1) {
            queryParamMap.put(request.url().queryParameterName(i), request.url().queryParameterValue(i))
        }
        val postBodyMap = mapOf<String, String>()
        val paramPart = generateSignatureParamPart(oAuthMetaData, queryParamMap, postBodyMap)
        val paramPartEncoded = escaper.escape(paramPart)

        val signatureBaseStringTemplate = "%1\$s&%2\$s&%3\$s"

        return String.format(signatureBaseStringTemplate,
                requestMethodEncoded,
                requestUrlEncoded,
                paramPartEncoded)
    }

    data class OAuthMetaData(val oAuthCb: String = "oob",
                             val oAuthConsumerKey: String,
                             val oAuthNonce: String,
                             val oAuthTimestamp: String,
                             val oAuthToken: String)

    fun generateSignatureParamPart(oAuthMetaData: OAuthMetaData,
                                   queryParamMap : Map<String, String>,
                                   postBodyMap : Map<String, String>): String {
        val paramPartMap = HashMap<String, String>()
        paramPartMap.put("oauth_callback", oAuthMetaData.oAuthCb)
        paramPartMap.put("oauth_consumer_key", oAuthMetaData.oAuthConsumerKey)
        paramPartMap.put("oauth_nonce", oAuthMetaData.oAuthNonce)
        paramPartMap.put("oauth_signature_method", "HMAC-SHA1")
        paramPartMap.put("oauth_timestamp", oAuthMetaData.oAuthTimestamp)
        paramPartMap.put("oauth_token", oAuthMetaData.oAuthToken)
        paramPartMap.put("oauth_version", "1.0")
        paramPartMap.putAll(queryParamMap)
        paramPartMap.putAll(postBodyMap)

        val sortedParamPartMap = paramPartMap.toSortedMap()

        val strBuilder = StringBuilder()
        for (entry in sortedParamPartMap.entries) {
            strBuilder.append("&").append(entry.key).append("=").append(entry.value)
        }

        return strBuilder.toString()
    }

    /**
     * https://tools.ietf.org/html/rfc5849#section-3.6
     */
    fun signaturePartEncode(signaturePart: String): String {
        val signaturePartUtf8 = String(signaturePart.toByteArray(Charsets.UTF_8))
        return escaper.escape(signaturePartUtf8)
    }

    fun generateAuthHeaderValue(
            oAuthCb: String,
            oAuthConsumerKey: String,
            oAuthNonce: String,
            oAuthSignature: String,
            oAuthTimestamp: String): String {
        val authHeaderValueTemplate = "OAuth oauth_callback=\"%1\$s\"," +
            "oauth_consumer_key=\"%2\$s\"," +
            "oauth_nonce=\"%3\$s\"," +
            "oauth_signature=\"%4\$s\"," +
            "oauth_signature_method=\"HMAC-SHA1\"," +
            "oauth_timestamp=\"%5\$s\"," +
            "oauth_version=\"1.0\""

        return String.format(authHeaderValueTemplate,
            oAuthCb,
            oAuthConsumerKey,
            oAuthNonce,
            oAuthSignature,
            oAuthTimestamp)
    }
}

